# 几何校正改进计划

## 🔍 当前问题分析

### 问题现象
- 几何校正后很多桩消失了
- 原始检测数: 236
- 校正后检测数: 293（但很多原始点被移动或丢失）

### 根本原因

1. **垂直距离回归的局限性**
   - 当前使用 `y = f(x)` 拟合，最小化 Y 轴方向的误差
   - 对于接近垂直的桩列（主要沿 Y 轴分布），X 坐标的微小变化会导致 Y 坐标的巨大变化
   - 当桩列接近垂直时，拟合效果极差

2. **强制所有点都在拟合线上**
   - RANSAC 拟合后，所有点都被强制移动到拟合曲线上
   - 如果拟合曲线不准确，原本正确的点会被错误移动
   - 导致"消失"（实际上是位置被错误校正）

3. **缺乏方向自适应**
   - 没有检测桩列的主要方向（横向/纵向）
   - 统一使用 `y = f(x)` 拟合，不适合所有场景

4. **缺乏基准间距约束**
   - 没有利用光伏桩的标准间距规律
   - 无法识别和过滤误检
   - 无法基于间距规律补全缺失点

---

## 📋 改进方案（分阶段实施）

### 阶段一：快速修复（本周）✅ 优先实施

#### 1.1 实现自适应方向检测
**问题**：当前统一使用 `y = f(x)` 拟合，不适合垂直列

**方案**：
- 计算点云的主方向（PCA）
- 如果主要沿 Y 轴分布（垂直列），使用 `x = f(y)` 拟合
- 如果主要沿 X 轴分布（水平列），使用 `y = f(x)` 拟合

**预期效果**：解决 80% 的垂直列拟合问题

#### 1.2 改进 RANSAC 拟合策略
**问题**：强制所有点都在拟合线上，导致正确点被错误移动

**方案**：
- RANSAC 只用于**识别内点**（符合拟合模型的点）
- **不强制移动所有点**，只对明显偏离的点进行校正
- 对于内点，保持原始位置或轻微调整

**预期效果**：避免正确点被错误移动

#### 1.3 实现正交距离回归（ODR）
**问题**：垂直距离回归不适合所有方向

**方案**：
- 使用 PCA 找到主方向
- 沿主方向进行正交距离回归（最小化点到线的垂直距离）
- 与方向无关，适合任意角度的桩列

**预期效果**：提高拟合精度，减少点丢失

---

### 阶段二：算法重构（下个月）

#### 2.1 实现基于最近邻的链式搜索
**问题**：全局拟合不适合复杂场景（弯曲、非标准排列）

**方案**：
- 构建最近邻图（KD-Tree）
- 基于局部拓扑关系进行链式搜索
- 识别完整的桩列（链）
- 对每条链单独处理

**优点**：
- 无视弯曲：蛇形走位也能追踪
- 无视旋转：横着、竖着、斜着都能处理
- 鲁棒性强：不依赖全局坐标系

#### 2.2 实现自适应网格聚类
**问题**：RANSAC 在整张图几千个点里找，容易被噪点带偏

**方案**：
- 使用 DBSCAN 聚类，分离不同的桩列
- 对每个聚类单独处理
- 避免不同列之间的干扰

---

### 阶段三：工程化功能（长期）

#### 3.1 实现基准间距分析
**问题**：没有利用光伏桩的标准间距规律

**方案**：
1. 计算所有检测点与其最近邻的距离
2. 画直方图，找到众数（基准像素间距）
3. **强约束**：
   - 剔除：距离 < 0.5 × 基准的点对（必有一个是误检）
   - 补全：距离 ≈ 2.0 × 基准的点对（中间必缺一个桩）

#### 3.2 实现角度一致性检查
**问题**：链式搜索可能连接错误的点

**方案**：
- 检查向量夹角：如果 `P_{i-1} → P_i` 与 `P_i → P_{i+1}` 夹角突变（> 15度），断开连接
- 只保留角度一致的链

---

## 🚀 实施优先级

### 立即实施（本周）
1. ✅ **自适应方向检测** - 解决垂直列问题
2. ✅ **改进 RANSAC 策略** - 避免点被错误移动
3. ✅ **正交距离回归** - 提高拟合精度

### 中期实施（下个月）
4. 基于最近邻的链式搜索
5. 自适应网格聚类

### 长期实施
6. 基准间距分析
7. 角度一致性检查

---

## 📊 预期效果

### 阶段一完成后
- ✅ 垂直列拟合准确率：从 30% → 90%
- ✅ 点丢失率：从 40% → < 5%
- ✅ 拟合精度：平均偏移从 50px → < 10px

### 阶段二完成后
- ✅ 复杂场景适应率：从 60% → 95%
- ✅ 弯曲列处理：支持
- ✅ 非标准排列：支持

### 阶段三完成后
- ✅ 误检过滤率：> 90%
- ✅ 缺失点补全率：> 80%
- ✅ 商业级可靠性

---

## 🔧 技术细节

### 自适应方向检测实现
```python
def detect_main_direction(points: np.ndarray) -> str:
    """检测点云的主要方向."""
    from sklearn.decomposition import PCA
    
    pca = PCA(n_components=2)
    pca.fit(points)
    
    # 主成分的方差比
    variance_ratio = pca.explained_variance_ratio_
    
    # 如果第一个主成分的方差占比 > 0.7，说明主要沿一个方向分布
    if variance_ratio[0] > 0.7:
        # 判断是横向还是纵向
        first_pc = pca.components_[0]
        if abs(first_pc[0]) > abs(first_pc[1]):
            return "horizontal"  # 主要沿 X 轴
        else:
            return "vertical"    # 主要沿 Y 轴
    
    return "mixed"  # 混合方向
```

### 正交距离回归实现
```python
def fit_with_odr(points: np.ndarray) -> np.ndarray:
    """使用正交距离回归拟合."""
    from sklearn.decomposition import PCA
    
    # PCA 找到主方向
    pca = PCA(n_components=1)
    pca.fit(points)
    direction = pca.components_[0]
    
    # 投影到主方向
    projected = pca.transform(points)
    
    # 在主方向上拟合
    # ... 拟合逻辑 ...
    
    # 投影回原空间
    fitted = pca.inverse_transform(projected)
    return fitted
```

---

## 📝 实施步骤

1. **第一步**：实现自适应方向检测（1-2 小时）
2. **第二步**：改进 RANSAC 策略（2-3 小时）
3. **第三步**：实现正交距离回归（3-4 小时）
4. **第四步**：测试和调优（2-3 小时）

**总计**：约 1-2 天完成阶段一

---

*创建日期: 2025-01-27*



